/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.9.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Decimal, Addr, Uint128, InstantiateMsg, PaginationConfig, ExecuteMsg, Binary, Cw20ReceiveMsg, QueryMsg, MigrateMsg, Vault, QueryAprInfoResponse, AprInfoItem, LockingAprItem, QueryBalancesResponse, Uint64, ArrayOfTupleOfAddrAndNullableUint64, Config, QueryEssenceResponse, ArrayOfTupleOfAddrAndEssenceInfo, EssenceInfo, ArrayOfTupleOfAddrAndArrayOfLockerInfo, LockerInfo, ArrayOfQueryEssenceListResponseItem, QueryEssenceListResponseItem, Boolean, QueryRewardsReductionInfoResponse, StakerInfoResponse, EssenceAndRewardsInfo, StakerInfo, ArrayOfTupleOfAddrAndStakerInfo, StateResponse, State, UsersAmountResponse, ArrayOfUint128 } from "./Staking.types";
export interface StakingReadOnlyInterface {
  contractAddress: string;
  queryConfig: () => Promise<Config>;
  queryPaginationConfig: () => Promise<PaginationConfig>;
  queryState: () => Promise<StateResponse>;
  queryStakerInfo: ({
    staker
  }: {
    staker: string;
  }) => Promise<StakerInfoResponse>;
  queryUsersAmount: () => Promise<UsersAmountResponse>;
  queryAggregatedVault: ({
    tier,
    user,
    vaultCreationDateList
  }: {
    tier?: number;
    user: string;
    vaultCreationDateList: number[];
  }) => Promise<Vault>;
  queryBalances: () => Promise<QueryBalancesResponse>;
  queryGovEssenceReduced: ({
    addressList
  }: {
    addressList: string[];
  }) => Promise<ArrayOfTupleOfAddrAndEssenceInfo>;
  queryEssence: ({
    user
  }: {
    user: string;
  }) => Promise<QueryEssenceResponse>;
  queryTotalEssence: () => Promise<QueryEssenceResponse>;
  queryWalletsPerTier: () => Promise<ArrayOfUint128>;
  queryStakingEssenceList: ({
    amount,
    blockTime,
    startFrom
  }: {
    amount: number;
    blockTime: number;
    startFrom?: string;
  }) => Promise<ArrayOfQueryEssenceListResponseItem>;
  queryLockingEssenceList: ({
    amount,
    startFrom
  }: {
    amount: number;
    startFrom?: string;
  }) => Promise<ArrayOfQueryEssenceListResponseItem>;
  queryAprInfo: ({
    amountToAdd,
    stakerAddress
  }: {
    amountToAdd?: Uint128;
    stakerAddress?: string;
  }) => Promise<QueryAprInfoResponse>;
  queryStakerInfoList: ({
    amount,
    startFrom
  }: {
    amount: number;
    startFrom?: string;
  }) => Promise<ArrayOfTupleOfAddrAndStakerInfo>;
  queryLockerInfoList: ({
    amount,
    startFrom
  }: {
    amount: number;
    startFrom?: string;
  }) => Promise<ArrayOfTupleOfAddrAndArrayOfLockerInfo>;
  queryTimeUntilDecreasingRewards: () => Promise<Uint64>;
  queryRewardsReductionInfo: () => Promise<QueryRewardsReductionInfoResponse>;
  queryPauseState: () => Promise<Boolean>;
  queryBondedVaultCreationDate: ({
    user
  }: {
    user: string;
  }) => Promise<Uint64>;
  queryBondedVaultCreationDateList: ({
    amount,
    startFrom
  }: {
    amount: number;
    startFrom?: string;
  }) => Promise<ArrayOfTupleOfAddrAndNullableUint64>;
  queryBeclipSupply: () => Promise<Uint128>;
}
export class StakingQueryClient implements StakingReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.queryConfig = this.queryConfig.bind(this);
    this.queryPaginationConfig = this.queryPaginationConfig.bind(this);
    this.queryState = this.queryState.bind(this);
    this.queryStakerInfo = this.queryStakerInfo.bind(this);
    this.queryUsersAmount = this.queryUsersAmount.bind(this);
    this.queryAggregatedVault = this.queryAggregatedVault.bind(this);
    this.queryBalances = this.queryBalances.bind(this);
    this.queryGovEssenceReduced = this.queryGovEssenceReduced.bind(this);
    this.queryEssence = this.queryEssence.bind(this);
    this.queryTotalEssence = this.queryTotalEssence.bind(this);
    this.queryWalletsPerTier = this.queryWalletsPerTier.bind(this);
    this.queryStakingEssenceList = this.queryStakingEssenceList.bind(this);
    this.queryLockingEssenceList = this.queryLockingEssenceList.bind(this);
    this.queryAprInfo = this.queryAprInfo.bind(this);
    this.queryStakerInfoList = this.queryStakerInfoList.bind(this);
    this.queryLockerInfoList = this.queryLockerInfoList.bind(this);
    this.queryTimeUntilDecreasingRewards = this.queryTimeUntilDecreasingRewards.bind(this);
    this.queryRewardsReductionInfo = this.queryRewardsReductionInfo.bind(this);
    this.queryPauseState = this.queryPauseState.bind(this);
    this.queryBondedVaultCreationDate = this.queryBondedVaultCreationDate.bind(this);
    this.queryBondedVaultCreationDateList = this.queryBondedVaultCreationDateList.bind(this);
    this.queryBeclipSupply = this.queryBeclipSupply.bind(this);
  }
  queryConfig = async (): Promise<Config> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_config: {}
    });
  };
  queryPaginationConfig = async (): Promise<PaginationConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_pagination_config: {}
    });
  };
  queryState = async (): Promise<StateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_state: {}
    });
  };
  queryStakerInfo = async ({
    staker
  }: {
    staker: string;
  }): Promise<StakerInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_staker_info: {
        staker
      }
    });
  };
  queryUsersAmount = async (): Promise<UsersAmountResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_users_amount: {}
    });
  };
  queryAggregatedVault = async ({
    tier,
    user,
    vaultCreationDateList
  }: {
    tier?: number;
    user: string;
    vaultCreationDateList: number[];
  }): Promise<Vault> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_aggregated_vault: {
        tier,
        user,
        vault_creation_date_list: vaultCreationDateList
      }
    });
  };
  queryBalances = async (): Promise<QueryBalancesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_balances: {}
    });
  };
  queryGovEssenceReduced = async ({
    addressList
  }: {
    addressList: string[];
  }): Promise<ArrayOfTupleOfAddrAndEssenceInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_gov_essence_reduced: {
        address_list: addressList
      }
    });
  };
  queryEssence = async ({
    user
  }: {
    user: string;
  }): Promise<QueryEssenceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_essence: {
        user
      }
    });
  };
  queryTotalEssence = async (): Promise<QueryEssenceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_total_essence: {}
    });
  };
  queryWalletsPerTier = async (): Promise<ArrayOfUint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_wallets_per_tier: {}
    });
  };
  queryStakingEssenceList = async ({
    amount,
    blockTime,
    startFrom
  }: {
    amount: number;
    blockTime: number;
    startFrom?: string;
  }): Promise<ArrayOfQueryEssenceListResponseItem> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_staking_essence_list: {
        amount,
        block_time: blockTime,
        start_from: startFrom
      }
    });
  };
  queryLockingEssenceList = async ({
    amount,
    startFrom
  }: {
    amount: number;
    startFrom?: string;
  }): Promise<ArrayOfQueryEssenceListResponseItem> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_locking_essence_list: {
        amount,
        start_from: startFrom
      }
    });
  };
  queryAprInfo = async ({
    amountToAdd,
    stakerAddress
  }: {
    amountToAdd?: Uint128;
    stakerAddress?: string;
  }): Promise<QueryAprInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_apr_info: {
        amount_to_add: amountToAdd,
        staker_address: stakerAddress
      }
    });
  };
  queryStakerInfoList = async ({
    amount,
    startFrom
  }: {
    amount: number;
    startFrom?: string;
  }): Promise<ArrayOfTupleOfAddrAndStakerInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_staker_info_list: {
        amount,
        start_from: startFrom
      }
    });
  };
  queryLockerInfoList = async ({
    amount,
    startFrom
  }: {
    amount: number;
    startFrom?: string;
  }): Promise<ArrayOfTupleOfAddrAndArrayOfLockerInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_locker_info_list: {
        amount,
        start_from: startFrom
      }
    });
  };
  queryTimeUntilDecreasingRewards = async (): Promise<Uint64> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_time_until_decreasing_rewards: {}
    });
  };
  queryRewardsReductionInfo = async (): Promise<QueryRewardsReductionInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_rewards_reduction_info: {}
    });
  };
  queryPauseState = async (): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_pause_state: {}
    });
  };
  queryBondedVaultCreationDate = async ({
    user
  }: {
    user: string;
  }): Promise<Uint64> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_bonded_vault_creation_date: {
        user
      }
    });
  };
  queryBondedVaultCreationDateList = async ({
    amount,
    startFrom
  }: {
    amount: number;
    startFrom?: string;
  }): Promise<ArrayOfTupleOfAddrAndNullableUint64> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_bonded_vault_creation_date_list: {
        amount,
        start_from: startFrom
      }
    });
  };
  queryBeclipSupply = async (): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_beclip_supply: {}
    });
  };
}
export interface StakingInterface extends StakingReadOnlyInterface {
  contractAddress: string;
  sender: string;
  receive: ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  stake: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unstake: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  lock: ({
    amount,
    lockTier
  }: {
    amount: Uint128;
    lockTier: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unlock: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  relock: ({
    fromTier,
    toTier,
    vaultCreationDate
  }: {
    fromTier: number;
    toTier: number;
    vaultCreationDate: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdraw: ({
    vaultCreationDate
  }: {
    vaultCreationDate: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  bond: ({
    vaultCreationDateList
  }: {
    vaultCreationDateList: number[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  bondFor: ({
    addressAndAmountList
  }: {
    addressAndAmountList: string[][];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unbond: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  rebond: ({
    amount,
    from,
    to
  }: {
    amount: Uint128;
    from: string;
    to: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  claim: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  aggregateVaults: ({
    tier,
    vaultCreationDateList
  }: {
    tier?: number;
    vaultCreationDateList: number[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  acceptAdminRole: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    admin,
    beclipAddress,
    beclipMinter,
    beclipWhitelist,
    daoTreasuryAddress,
    eclipPerSecondMultiplier,
    equinoxVoter,
    lockSchedule,
    penaltyMultiplier
  }: {
    admin?: string;
    beclipAddress?: string;
    beclipMinter?: string;
    beclipWhitelist?: string[];
    daoTreasuryAddress?: string;
    eclipPerSecondMultiplier?: Decimal;
    equinoxVoter?: string;
    lockSchedule?: number[][][];
    penaltyMultiplier?: Decimal;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updatePaginationConfig: ({
    paginationAmount
  }: {
    paginationAmount?: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  replenishBalance: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  decreaseBalance: ({
    amount
  }: {
    amount: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  pause: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unpause: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  fixBondedVault: ({
    bondedVaultCreationDate,
    tier4VaultCreationDate,
    user
  }: {
    bondedVaultCreationDate?: number;
    tier4VaultCreationDate?: number;
    user: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class StakingClient extends StakingQueryClient implements StakingInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.receive = this.receive.bind(this);
    this.stake = this.stake.bind(this);
    this.unstake = this.unstake.bind(this);
    this.lock = this.lock.bind(this);
    this.unlock = this.unlock.bind(this);
    this.relock = this.relock.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.bond = this.bond.bind(this);
    this.bondFor = this.bondFor.bind(this);
    this.unbond = this.unbond.bind(this);
    this.rebond = this.rebond.bind(this);
    this.claim = this.claim.bind(this);
    this.aggregateVaults = this.aggregateVaults.bind(this);
    this.acceptAdminRole = this.acceptAdminRole.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.updatePaginationConfig = this.updatePaginationConfig.bind(this);
    this.replenishBalance = this.replenishBalance.bind(this);
    this.decreaseBalance = this.decreaseBalance.bind(this);
    this.pause = this.pause.bind(this);
    this.unpause = this.unpause.bind(this);
    this.fixBondedVault = this.fixBondedVault.bind(this);
  }
  receive = async ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive: {
        amount,
        msg,
        sender
      }
    }, fee, memo, _funds);
  };
  stake = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      stake: {}
    }, fee, memo, _funds);
  };
  unstake = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unstake: {}
    }, fee, memo, _funds);
  };
  lock = async ({
    amount,
    lockTier
  }: {
    amount: Uint128;
    lockTier: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      lock: {
        amount,
        lock_tier: lockTier
      }
    }, fee, memo, _funds);
  };
  unlock = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unlock: {}
    }, fee, memo, _funds);
  };
  relock = async ({
    fromTier,
    toTier,
    vaultCreationDate
  }: {
    fromTier: number;
    toTier: number;
    vaultCreationDate: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      relock: {
        from_tier: fromTier,
        to_tier: toTier,
        vault_creation_date: vaultCreationDate
      }
    }, fee, memo, _funds);
  };
  withdraw = async ({
    vaultCreationDate
  }: {
    vaultCreationDate: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {
        vault_creation_date: vaultCreationDate
      }
    }, fee, memo, _funds);
  };
  bond = async ({
    vaultCreationDateList
  }: {
    vaultCreationDateList: number[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond: {
        vault_creation_date_list: vaultCreationDateList
      }
    }, fee, memo, _funds);
  };
  bondFor = async ({
    addressAndAmountList
  }: {
    addressAndAmountList: string[][];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond_for: {
        address_and_amount_list: addressAndAmountList
      }
    }, fee, memo, _funds);
  };
  unbond = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond: {}
    }, fee, memo, _funds);
  };
  rebond = async ({
    amount,
    from,
    to
  }: {
    amount: Uint128;
    from: string;
    to: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      rebond: {
        amount,
        from,
        to
      }
    }, fee, memo, _funds);
  };
  claim = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim: {}
    }, fee, memo, _funds);
  };
  aggregateVaults = async ({
    tier,
    vaultCreationDateList
  }: {
    tier?: number;
    vaultCreationDateList: number[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      aggregate_vaults: {
        tier,
        vault_creation_date_list: vaultCreationDateList
      }
    }, fee, memo, _funds);
  };
  acceptAdminRole = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accept_admin_role: {}
    }, fee, memo, _funds);
  };
  updateConfig = async ({
    admin,
    beclipAddress,
    beclipMinter,
    beclipWhitelist,
    daoTreasuryAddress,
    eclipPerSecondMultiplier,
    equinoxVoter,
    lockSchedule,
    penaltyMultiplier
  }: {
    admin?: string;
    beclipAddress?: string;
    beclipMinter?: string;
    beclipWhitelist?: string[];
    daoTreasuryAddress?: string;
    eclipPerSecondMultiplier?: Decimal;
    equinoxVoter?: string;
    lockSchedule?: number[][][];
    penaltyMultiplier?: Decimal;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        admin,
        beclip_address: beclipAddress,
        beclip_minter: beclipMinter,
        beclip_whitelist: beclipWhitelist,
        dao_treasury_address: daoTreasuryAddress,
        eclip_per_second_multiplier: eclipPerSecondMultiplier,
        equinox_voter: equinoxVoter,
        lock_schedule: lockSchedule,
        penalty_multiplier: penaltyMultiplier
      }
    }, fee, memo, _funds);
  };
  updatePaginationConfig = async ({
    paginationAmount
  }: {
    paginationAmount?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_pagination_config: {
        pagination_amount: paginationAmount
      }
    }, fee, memo, _funds);
  };
  replenishBalance = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      replenish_balance: {}
    }, fee, memo, _funds);
  };
  decreaseBalance = async ({
    amount
  }: {
    amount: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      decrease_balance: {
        amount
      }
    }, fee, memo, _funds);
  };
  pause = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pause: {}
    }, fee, memo, _funds);
  };
  unpause = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unpause: {}
    }, fee, memo, _funds);
  };
  fixBondedVault = async ({
    bondedVaultCreationDate,
    tier4VaultCreationDate,
    user
  }: {
    bondedVaultCreationDate?: number;
    tier4VaultCreationDate?: number;
    user: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      fix_bonded_vault: {
        bonded_vault_creation_date: bondedVaultCreationDate,
        tier_4_vault_creation_date: tier4VaultCreationDate,
        user
      }
    }, fee, memo, _funds);
  };
}